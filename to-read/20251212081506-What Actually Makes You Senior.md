---
type: "to-read"
id: 20251212081206
created: 2025-12-12T08:15:06
source:
  - "https://terriblesoftware.org/2025/11/25/what-actually-makes-you-senior/?utm_source=tldrdev"
tags:
reviewd: false
---
[Skip to content](https://terriblesoftware.org/2025/11/25/what-actually-makes-you-senior/?utm_source=tldrdev#wp--skip-link--target)

People love to describe senior engineers with a big checklist: architecture, communication, ownership, leadership, etc.

But if you strip away the title, the salary, and the years of experience, there’s one core skill that separates senior+ engineers from everyone else: **reducing ambiguity**. Everything else flows from that.

Here’s what I mean. A mid-level engineer can absolutely crush a well-defined problem. Give them a clear spec, some reasonable constraints, and they’ll deliver solid work. Don’t get me wrong, that *is* valuable.

The moment you hand them something fuzzy, though, like *“we need to improve performance”*, *“users are complaining about the onboarding flow”* or *“we should probably think about scaling”*, that’s when you see the difference. Not because mid-level engineers are bad at their jobs, but because ambiguous problems require something more.

Senior engineers look at the big, messy, abstract thing and start digging:

- They ask questions nobody else thought to ask.
- They separate what matters from noise.
- They identify what should be done now vs. what to punt.

It’s one of the reasons why senior engineers are worth their salaries. Not just because they write good code (which they often do!), but because **they derisk projects**. They turn *“I don’t even know what this is”* into *“there are two small projects and one thing we should cut.”*

And you know what’s funny? When senior engineers do this well, it looks easy. Like nothing was even done. The project just… goes smoothly. Fewer surprises, production fires, or emergency meetings. But what actually happened was that someone did a lot of invisible work upfront.

Just a few questions, as an example, that senior+ engineers ask:

1. **What problem are we actually trying to solve?** (Not what solution do we want, but what’s the underlying problem?)
2. **Who’s the user here and what’s painful for them?** (They try to be specific. “Users” isn’t an answer.)
3. **What are we assuming that might be wrong?** (Every plan has hidden assumptions.)
4. **What happens if we’re wrong and ship this anyway?** (How bad is the downside?)

In other words, they first make the problem clear. Then, and only then, they go to solve it.

One frustrating part is that many companies are still terrible at hiring for this. Job descriptions list technologies and years of experience. Interviews focus on LeetCode. None of that really measures your ability to take a vague product requirement and turn it into a shippable plan.

So we end up with “senior” engineers who can reverse a binary tree on the whiteboard but freeze when the spec is half-baked.

I’m not saying the other stuff doesn’t matter. Architecture matters. Communication matters. **But those things are way more valuable once you’ve figured out what you’re actually building**. If you can’t reduce ambiguity, all your other skills are just elegant ways of solving the wrong problem.

So if you’re wondering whether you’re operating at a senior+ level, here’s one test: What happens when someone hands you something abstract/fuzzy/complex? Do you wait for someone else to clarify it for you? Do you start coding immediately and hope for the best? Or do you spend time up front making it concrete enough that you and your team can actually execute with confidence?

If it’s the last one, you’re probably already there. If it’s not, the good news is this isn’t talent, but practice: start with the next vague ticket that’s assigned to you.

Like Loading…

![](https://pixel.wp.com/g.gif?blog=239592469&v=wpcom&tz=-3&user_id=0&post=410&subd=terriblesoftwareorg&host=terriblesoftware.org&ref=&utm_source=tldrdev&rand=0.5902042588857007)