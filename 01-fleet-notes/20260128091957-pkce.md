---
tags:
  - oauth
id: 20260128092002
created: 2026-01-28 09:20:02
status:
  - in_progress
type: fleet-note
aliases:
  - pkce
---
PKCE 让“截获 authorization code 也没用”的关键点是：**把授权请求（/auth）和换 token 请求（/token）用一个只在 CLI 里保存的秘密随机值绑定起来**。RFC 7636 把它作为对“authorization code interception attack”的缓解措施来定义。([IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc7636?utm_source=chatgpt.com "RFC 7636 - Proof Key for Code Exchange by OAuth Public ..."))

下面按机制拆开说明（以 Keycloak + Standard Flow 为例）。

---

## 参与方

- **CLI（Public Client）**：无法安全保存 `client_secret`，因此不能靠“客户端密钥”证明自己。
    
- **Browser（User Agent）**：负责让用户输入用户名密码。
    
- **Keycloak（Authorization Server）**：签发 code / token。
    
- **攻击者（Attacker）**：设想它能截获回调中的 `code`（例如本机恶意进程、代理/日志、某些重定向劫持等）。
    

---

## PKCE 的两段式“承诺-证明”机制（commitment → proof）

### 1) CLI 生成 `code_verifier`（秘密，只留在 CLI）

- 高熵随机字符串（不要可预测）。
    
- CLI 把它存在内存/临时存储，**不通过浏览器发送**。
    

### 2) CLI 计算 `code_challenge`（公开，可放到 URL）

常用方法 `S256`：

```text
code_challenge = BASE64URL( SHA256( code_verifier ) )
code_challenge_method = S256
```

`S256` 和 `plain` 是 PKCE 规范里定义的两种方法。([IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc7636?utm_source=chatgpt.com "RFC 7636 - Proof Key for Code Exchange by OAuth Public ..."))

### 3) CLI 打开浏览器访问 Keycloak 的授权端点 `/auth`

把 challenge 放到授权请求里：

```text
.../protocol/openid-connect/auth?...
  &response_type=code
  &code_challenge=...
  &code_challenge_method=S256
  &state=...
```

Keycloak（以及 OIDC）采用 Code Flow 的好处是：**token 不暴露在浏览器里**，浏览器拿到的只是 code。([OpenID Foundation](https://openid.net/specs/openid-connect-core-1_0.html?utm_source=chatgpt.com "OpenID Connect Core 1.0 incorporating errata set 2"))

### 4) Keycloak 登录成功后签发 `code`，并把“challenge 绑定到这个 code”

Keycloak 会把这次请求里的 `code_challenge`（以及 client_id、redirect_uri 等上下文）与后续要发放的 authorization code 关联起来（概念上就是“把 code 钉死在这个 challenge 上”）。PKCE 的安全性前提正是这种绑定。([IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc7636?utm_source=chatgpt.com "RFC 7636 - Proof Key for Code Exchange by OAuth Public ..."))

### 5) 浏览器回调到你的本地地址，只带 `code`（以及 `state`）

例如：

```text
http://127.0.0.1:18080/callback?code=...&state=...
```

此处假设攻击者能截获 `code`。

### 6) CLI 用 `code` + 原始 `code_verifier` 调用 `/token` 换 token

```text
POST .../protocol/openid-connect/token
  grant_type=authorization_code
  code=...
  redirect_uri=...
  client_id=...
  code_verifier=...   (关键)
```

### 7) Keycloak 校验：用同样算法把 `code_verifier` 再算一遍 challenge，必须与第 3 步一致

- Keycloak 取到 `code_verifier`
    
- 计算 `BASE64URL(SHA256(code_verifier))`
    
- 与当初跟 `code` 绑定的 `code_challenge` 比较
    
- 只有一致才发 token，否则拒绝（比如 `invalid_grant`）
    

---

## 为什么“截获 code 没用”

攻击者即使拿到了 `code`，也必须在 `/token` 请求里提供正确的 `code_verifier` 才能成功。

- `code_verifier` **从不经过浏览器/回调**，攻击者通常拿不到。
    
- 攻击者看到的 `code_challenge` 是 `SHA256(code_verifier)` 的 base64url 表示；在 `S256` 下，从 challenge 反推 verifier 需要做哈希原像攻击，实践上不可行（前提是 verifier 足够随机/足够长）。([IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc7636?utm_source=chatgpt.com "RFC 7636 - Proof Key for Code Exchange by OAuth Public ..."))
    
- 所以攻击者“只有 code，没有 verifier”→ 无法换到 token。
    

这就是 PKCE 的“Proof Key”含义：**换 token 的一方必须证明自己持有最初生成的那个 key（verifier）**。

---

## `plain` 为什么不推荐

如果 `code_challenge_method=plain`，则 `code_challenge == code_verifier`。  
那么 challenge 一旦出现在授权 URL 里，就等于把 verifier 暴露了——截获 URL 的人就可能直接拿 code 去换 token。因此实际系统通常要求 `S256`。([IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc7636?utm_source=chatgpt.com "RFC 7636 - Proof Key for Code Exchange by OAuth Public ..."))

---

## 你遇到的 `Missing parameter: code_challenge_method` 的根本原因

Keycloak 这边识别到你在走 PKCE（通常是该 Client 配了 PKCE 相关设置或策略），但你的授权请求缺少 `code_challenge_method`，因此直接判定请求不完整。Keycloak 文档也说明了：只有当客户端发来 PKCE 参数时才应用 PKCE；并区分 `S256`/`plain`。([Keycloak](https://www.keycloak.org/docs/latest/server_admin/index.html?utm_source=chatgpt.com "Server Administration Guide"))

---

## 建议的实现要点（CLI）

1. 每次登录生成新的 `state`、`code_verifier`（以及可选 `nonce`）。
    
2. 浏览器 URL 必带：`code_challenge` + `code_challenge_method=S256` + `state`。
    
3. 回调只接受带正确 `state` 的请求（防串线/CSRF）。
    
4. `/token` 交换必带：`code_verifier`。
    

如果你贴出你实际拼出来的 `/auth` URL（去掉敏感值也行），可以逐项指出：哪些参数缺失/拼错、以及 Keycloak 为什么会认为该 Client 必须用 PKCE。

# References