---
tags:
  - database
id: 20260116100520
created: 2026-01-16 10:05:20
status:
  - pending
  - done
  - in_progress
type: fleet-note
aliases:
  - wal技术
---
我会先用一句话解释 WAL 的核心目标，然后分别讲 MySQL（以 InnoDB 为主）和 PostgreSQL 的具体实现细节与关键数据结构，最后按版本演进梳理重要里程碑并给出对比要点与参考来源。

WAL（Write-Ahead Logging，预写式日志）的核心规则是：**先把“将要对数据页做的修改”按顺序追加写到日志并落盘，再允许把对应的数据页刷盘**。这样即使宕机，也能通过“重放日志”把数据页恢复到一致状态。

---

## MySQL 的 WAL 是什么（以 InnoDB 为主）

在 MySQL 语境里，“WAL”通常指 **InnoDB Redo Log（重做日志）**。MySQL 还另外有 **Binary Log（binlog）**，两者分工不同：

- **Redo Log（物理 WAL）**：面向“页修改”的物理日志，用于 **崩溃恢复**（Crash Recovery）。([MySQL Developer Zone](https://dev.mysql.com/doc/refman/9.0/en/innodb-redo-log.html?utm_source=chatgpt.com "MySQL 9.0 Reference Manual :: 17.6.5 Redo Log"))
    
- **Binlog（逻辑日志）**：面向“逻辑变更事件”（statement/row events）的日志，用于 **复制与基于时间点恢复（PITR）**，以及跨存储引擎的一致提交。([MySQL Developer Zone](https://dev.mysql.com/doc/refman/8.1/en/binary-log.html?utm_source=chatgpt.com "MySQL 8.4 Reference Manual :: 7.4.4 The Binary Log"))
    

### InnoDB Redo Log 的具体实现（写入路径与恢复）

1. **修改发生时**
    
    - 线程在内存里修改 Buffer Pool 中的数据页，同时生成 redo record，先写入 **log buffer（内存）**。
        
2. **提交时（durability 的关键点）**
    
    - 根据 `innodb_flush_log_at_trx_commit`，把 log buffer 写入 redo 文件并决定是否 `fsync`。这是 InnoDB 的“WAL 先行”保证。
        
3. **刷脏页与 checkpoint**
    
    - 脏页异步刷到表空间文件。系统维护 **LSN** 与 **checkpoint LSN**，checkpoint 向前推进后，旧 redo 空间可复用（循环写）。MySQL 8.0 的 redo 设计把 redo 明确描述为生产者消费者队列，依赖 fuzzy checkpoint 回收空间。([MySQL Developer Zone](https://dev.mysql.com/blog-archive/mysql-8-0-new-lock-free-scalable-wal-design/?utm_source=chatgpt.com "MySQL 8.0: New Lock free, scalable WAL design"))
        
4. **崩溃恢复**
    
    - 启动时从最后 checkpoint 开始 **重放 redo**，把尚未落盘的数据页修改补齐；同时借助 undo 等机制回滚未提交事务（这是 InnoDB 的典型“redo + undo”恢复模型）。
        

### Redo 与 Binlog 的一致性：两阶段提交（2PC）与组提交

为了保证“**InnoDB 数据文件/redo**”与“**binlog**”一致（否则会出现主库提交了但 binlog 没记下，或 binlog 记下了但引擎没提交），MySQL 采用 **两阶段提交（2PC）** 思路，并要求合理配置 `sync_binlog` 等参数来确保持久化顺序。([MySQL Developer Zone](https://dev.mysql.com/doc/refman/8.1/en/binary-log.html?utm_source=chatgpt.com "MySQL 8.4 Reference Manual :: 7.4.4 The Binary Log"))

同时，为降低每事务一次 fsync 的开销，MySQL 引入/强化了 **binlog group commit**，把一批事务合并刷盘以提升吞吐。([mysqlmusings.blogspot.com](https://mysqlmusings.blogspot.com/2012/06/binary-log-group-commit-in-mysql-56.html?utm_source=chatgpt.com "Binary Log Group Commit in MySQL 5.6"))

---

## PostgreSQL 的 WAL 是什么

PostgreSQL 的 WAL 是内核里一等公民：**崩溃恢复、PITR、流复制、逻辑解码/逻辑复制**都围绕同一套 WAL 机制展开。官方文档对其定义就是：所有对数据文件的更改都会记录到 WAL，宕机后通过重放恢复一致性。([postgresql.org](https://www.postgresql.org/docs/current/continuous-archiving.html?utm_source=chatgpt.com "25.3. Continuous Archiving and Point-in-Time Recovery ..."))

### PostgreSQL WAL 的具体实现（文件组织、写入、恢复）

**文件组织与地址：**

- WAL 存在数据目录下的 `pg_wal`（PG10 之前叫 `pg_xlog`）。([postgresql.org](https://www.postgresql.org/docs/release/10.0/ "PostgreSQL: Release Notes"))
    
- 以 **segment 文件**形式保存，默认每段 **16MB**；段内再按页（默认 8KB）组织；位置用 **LSN** 标识。([postgresql.org](https://www.postgresql.org/docs/current/wal-internals.html?utm_source=chatgpt.com "Documentation: 18: 28.6. WAL Internals"))
    

**写入与提交：**

- WAL record 先写入 WAL buffer（内存），提交时确保 WAL 按需落盘，然后数据页可延后刷盘（同样是 WAL 的“先日志后数据页”）。
    
- 通过 checkpoint 形成恢复起点，宕机后从 checkpoint 起重放 WAL。
    

**防“撕裂页”（torn page）：full_page_writes**

- PostgreSQL 没有 InnoDB 的 doublewrite buffer，而是用 `full_page_writes`：**每个数据页在一次 checkpoint 之后的首次修改，会把整页镜像写入 WAL**，避免恢复时读到半写入的数据页。([postgresqlco.nf](https://postgresqlco.nf/doc/en/param/full_page_writes/?utm_source=chatgpt.com "PostgreSQL Documentation: full_page_writes parameter"))
    

**WAL 详细度分级：wal_level**

- `wal_level=minimal/replica/logical` 决定 WAL 里包含的信息量；`logical` 会加入逻辑解码所需信息。([postgresql.org](https://www.postgresql.org/docs/current/runtime-config-wal.html?utm_source=chatgpt.com "PostgreSQL: Documentation: 18: 19.5. Write Ahead Log"))
    

---

## 版本演进脉络（关键里程碑）

### MySQL / InnoDB

- **MySQL 5.6**：引入并完善 **binlog group commit**，显著减少 binlog 刷盘次数，提升开启 binlog 时的写入吞吐。([mysqlmusings.blogspot.com](https://mysqlmusings.blogspot.com/2012/06/binary-log-group-commit-in-mysql-56.html?utm_source=chatgpt.com "Binary Log Group Commit in MySQL 5.6"))
    
- **MySQL 5.7.5**：redo log 格式发生不兼容变化，引入如 `MLOG_FILE_NAME` 等记录类型，用于**简化崩溃恢复时的 tablespace 发现**，减少恢复前文件系统扫描。([MySQL Developer Zone](https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-5.html?utm_source=chatgpt.com "Changes in MySQL 5.7.5 (2014-09-25, Milestone 15)"))
    
- **MySQL 8.0**：InnoDB redo（WAL）子系统做了并发与可扩展性重构，提出“lock-free scalable WAL design”等改进点。([MySQL Developer Zone](https://dev.mysql.com/blog-archive/mysql-8-0-new-lock-free-scalable-wal-design/?utm_source=chatgpt.com "MySQL 8.0: New Lock free, scalable WAL design"))
    
- **MySQL 8.0.30**：支持 **Dynamic InnoDB Redo Log**，可在线调整 redo 容量；`innodb_log_file_size/innodb_log_files_in_group` 被 `innodb_redo_log_capacity` 取代并进入弃用流程。([MySQL Developer Zone](https://dev.mysql.com/blog-archive/dynamic-innodb-redo-log-in-mysql-80/?utm_source=chatgpt.com "Dynamic InnoDB Redo Log in MySQL 8.0"))
    
- **MySQL 9.3**（创新版本线）：明确移除了上述已弃用参数。([MySQL Developer Zone](https://dev.mysql.com/doc/relnotes/mysql/9.3/en/news-9-3-0.html?utm_source=chatgpt.com "Changes in MySQL 9.3.0 (2025-04-15, Innovation Release)"))
    

### PostgreSQL

- **长期基础能力**：WAL 一直是 Postgres 崩溃恢复与 PITR 的基础。([postgresql.org](https://www.postgresql.org/docs/current/continuous-archiving.html?utm_source=chatgpt.com "25.3. Continuous Archiving and Point-in-Time Recovery ..."))
    
- **PostgreSQL 9.0（2010-09-20）**：引入 **Streaming Replication** 与 Hot Standby，WAL 从“按整段文件传输”走向“可流式发送”。([postgresql.org](https://www.postgresql.org/docs/release/9.0.0/?utm_source=chatgpt.com "PostgreSQL: Release Notes"))
    
- **PostgreSQL 9.4**：引入 **Replication Slots**，并提供逻辑解码（logical decoding）基础构件，解决“下游短线导致 WAL 过早回收”的可靠性问题。([EDB](https://www.enterprisedb.com/blog/streaming-replication-slots-postgresql-94?utm_source=chatgpt.com "Streaming replication slots in PostgreSQL 9.4"))
    
- **PostgreSQL 10（2017-10-05）**：提供内置 **逻辑复制（发布订阅）**；同时把 `pg_xlog` 改名为 `pg_wal` 并统一术语。([postgresql.org](https://www.postgresql.org/docs/release/10.0/ "PostgreSQL: Release Notes"))
    
- **PostgreSQL 11（2018-10-18）**：允许在 `initdb` 时设置 WAL 文件（segment）大小，过去只能编译期决定。([postgresql.org](https://www.postgresql.org/docs/release/11.0/ "PostgreSQL: Release Notes"))
    

---

## 核心差异总结（抓重点）

- **“一套 WAL vs 两套日志”**
    
    - PostgreSQL：一个 WAL 覆盖崩溃恢复、复制、PITR、逻辑解码（通过 `wal_level`）。([postgresql.org](https://www.postgresql.org/docs/current/runtime-config-wal.html?utm_source=chatgpt.com "PostgreSQL: Documentation: 18: 19.5. Write Ahead Log"))
        
    - MySQL：InnoDB redo 负责崩溃恢复；binlog 负责复制与 PITR，并通过 2PC 保证与引擎一致。([MySQL Developer Zone](https://dev.mysql.com/doc/refman/9.0/en/innodb-redo-log.html?utm_source=chatgpt.com "MySQL 9.0 Reference Manual :: 17.6.5 Redo Log"))
        
- **防撕裂页策略不同**
    
    - PostgreSQL：`full_page_writes` 写整页镜像进 WAL。([postgresqlco.nf](https://postgresqlco.nf/doc/en/param/full_page_writes/?utm_source=chatgpt.com "PostgreSQL Documentation: full_page_writes parameter"))
        
    - InnoDB：典型做法是 doublewrite buffer（这里不展开实现细节）。
        
- **演进方向**
    
    - MySQL：更多围绕 redo/binary log 的并发、提交路径、在线可调参数。([MySQL Developer Zone](https://dev.mysql.com/blog-archive/mysql-8-0-new-lock-free-scalable-wal-design/?utm_source=chatgpt.com "MySQL 8.0: New Lock free, scalable WAL design"))
        
    - PostgreSQL：围绕 WAL 的复制形态（流复制、slot、逻辑复制）与可运维性（目录改名、initdb 可配 segsize）。([postgresql.org](https://www.postgresql.org/docs/release/9.0.0/?utm_source=chatgpt.com "PostgreSQL: Release Notes"))
        

如果你希望更“落地”，我可以按一次事务提交的**时间线**把两者的关键步骤画成对照（redo/binlog/WAL buffer/fsync/checkpoint/replication）并标出可能的性能瓶颈点与常见参数组合。

# References