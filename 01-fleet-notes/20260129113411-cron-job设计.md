---
tags:
  - knative
id: 20260129113418
created: 2026-01-29 11:34:18
status:
  - done
type: fleet-note
aliases:
  - cron-job设计
---
我先快速做三件事：1）把现有 eventing 领域文档和 Trigger/PingSource 相关实现扫一遍；2）梳理当前 CommandHandler/Outbox 异步创建的模式；3）给出一个对齐 DDD 分层的 CronJob 设计（命令、事件、流程编排与幂等）。

Created 3 todos

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/docs/domain/eventing-domain.md#1-1), lines 1 to 260

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/docs/requirement/eventing-requirement.md)

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/command/handler/CreateSourceCommandHandler.java)

Searched for regex `PingSource|Trigger|CreateTrigger|CreatePing|SourceCommandHandler|Outbox|InboxGuard|HandlerRegistry` (`**/*.java`), 50 results

我已经确认 eventing 领域文档里明确采用“写侧落库 + Outbox 发布 + 异步 Apply/Observe 收敛”的模式；下一步我会把 Trigger/Source 的事件处理链路（SpecAccepted → ApplyRequested → Gateway apply）读出来，然后基于同一套路给 CronJob 的编排方案。

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/command/handler/CreateTriggerCommandHandler.java)

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/event/TriggerSpecAcceptedEventHandler.java)

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/event/TriggerApplyRequestedEventHandler.java)

Searched for regex `SourceSpecAcceptedEventHandler|SourceApplyRequestedEventHandler|KnativeSourceObservedEventHandler` (`**/hive-backend-app/src/main/java/**/*.java`), 5 results

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/event/SourceSpecAcceptedEventHandler.java)

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/event/SourceApplyRequestedEventHandler.java)

Read [](file:///Users/ryan/GitHubProjects/RonghuanZhang/hive-backend-copilot-eventing/hive-backend-app/src/main/java/ai/saharalabs/hive/app/eventing/event/KnativeSourceObservedEventHandler.java)

Completed: *Read eventing docs* (1/3)

1) 需求该对齐到领域模型还是 CommandHandler？要不要 CommandHandler 调其他 CommandHandler？

- 先用一句话定性：你这个“CronJob（对外 API）= 内部组合创建 Trigger + PingSource”的诉求，本质是一个“用户用例/应用编排”，不等同于 Knative 的某一个原子资源，所以不要硬塞进现有 Trigger/Source 的单个聚合里。
- 在这个仓库的模式里（见 eventing-domain. Md 的流程与最终一致描述），我建议优先落在 **App 层一个新的用例 CommandHandler（或 Application Service）**：`CreateCronJobCommandHandler`，它在一个事务里写入两个聚合（TriggerAggregate + SourceAggregate）并写 Outbox，然后沿用既有的异步 Apply/Observe 链路去创建/收敛外部资源。
- 是否要建“CronJob”领域模型？
  - 如果你打算让用户“以 CronJob 为中心”做 CRUD/列表/更新，且希望系统内部对 CronJob 有独立的业务不变量（比如名字规则、必须同时存在 Trigger+Source、更新/删除要联动、整体状态 READY 的判定规则），那 CronJob 是**可成为领域概念**的。
  - 但结合当前代码现状（Trigger/Source 已经是聚合，且 Apply/Observe 都围绕它们），更低成本且更贴合现状的做法是：**CronJob 作为 App 层用例 + Query 侧组合视图**，不强行新增一个新的 domain aggregate（除非后续要做更复杂的编排/重试/补偿/状态机）。
- CommandHandler 要不要调用其它 CommandHandler？
  - 不建议。原因：CommandHandler 在这里就是事务边界（你可以对照 CreateSourceCommandHandler. Java 和 CreateTriggerCommandHandler. Java 的风格）。互调会带来嵌套事务、重复校验、日志与幂等语义混乱。
  - 正确复用方式：把“通用校验/组装逻辑”抽成 app 层的 assembler/validator（类似现有 `EventingSpecAssembler`），或者直接在新的 `CreateCronJobCommandHandler` 里复用相同的 repository / assembler 流程。

2) 应该怎么设计实现？（Trigger/Source 异步创建）

下面给一个“完全对齐现有实现风格”的设计（不改你们已有的异步链路，只是加一层封装）。

**核心建模（对外 CronJob = 组合资源）**
- 对外资源：CronJob（用户理解的对象）
- 内部资源：
  - PingSource：负责按 cron schedule 产生事件，sink 指向 broker（通常是 default broker）
  - Trigger：从 broker 订阅并过滤“只属于该 CronJob 的事件”，然后转发到最终 sink（通常是 tenant 内 ksvc）

**关键点：如何把 PingSource 的事件“路由到对应 Trigger”？**
- 依赖 PingSource 的 `ceOverrides`（领域文档里 Source 对齐 Knative 字段能力也提到会有 ceOverrides），在 PingSource 事件上打稳定的属性，比如：
  - `hiveCronJobName=<cronJobName>` 或 `hiveCronJobId=<uuid>`
- Trigger 的 `CloudEventFilter` 过滤这些属性，从而只吃该 CronJob 的事件，然后把 sink 转到用户想要的目标服务。

**写侧用例：CreateCronJobCommand**
- 新增命令：`CreateCronJobCommand(tenantId, cronJobName, schedule, targetSink, brokerName?, payload?, idempotencyKey)`
- Handler（单事务）做这些事：
  1) tenant / namespace 解析：沿用 `TenantNamespaceResolver`（同 CreateTrigger/CreateSource）
  2) targetSink 校验：如果是 TenantKsvcDestination，则用 `ServiceRepository` 校验 service 存在（同现有逻辑）
  3) 名字派生（保证幂等与可重放）：
     - `sourceName = "cron-" + cronJobName`
     - `triggerName = "cron-" + cronJobName`
     - （或加后缀区分，但必须稳定且 tenant 内唯一）
  4) 组装 SourceSpec（PingSource）：
     - `schedule = command.schedule`
     - `sink = BrokerDestination(default 或 command.brokerName)`（注意：你们领域允许 sink=BrokerDestination，但 app 层 assembler 是否已支持要确认；如果暂时只支持 URL/ksvc，那就先让 PingSource sink=URL/ksvc 并调整“为什么需要 Trigger”的链路）
     - `ceOverrides` 写入 `hiveCronJobName/hiveCronJobId`
  5) 组装 TriggerSpec：
     - BrokerName = default（或 command. BrokerName）
     - filter = match `hiveCronJobName/hiveCronJobId`
     - Sink = targetSink（ksvc 或 external URL）
  6) 创建并保存两个聚合：`SourceAggregate.create(...)` + `TriggerAggregate.create(...)`
  7) 把两者 `pullEvents()` 写入 Outbox（同现有 pattern）

**异步落地：复用既有 ApplyRequested handlers**
- Source：由 SourceApplyRequestedEventHandler. Java 调 gateway `applySource(...)`
- Trigger：由 TriggerApplyRequestedEventHandler. Java 调 gateway `applyTrigger(...)`
- 收敛：Knative 观测事件进来后，分别由 KnativeObservedEventHandler 更新聚合状态（例如 Source 是 KnativeSourceObservedEventHandler. Java）

**CronJob 的“整体状态”怎么对外呈现？**
- 推荐做法（低侵入）：在 Query 侧新增 `CronJobView`，通过 `cronJobName` 推导出对应的 `sourceName/triggerName`（或用同一标签/注解关联），然后组合两个资源的状态：
  - READY：Trigger 和 Source 都 READY
  - FAILED：任一 FAILED
  - PENDING/PROVISIONING：任一未收敛
  - DELETING：任一处于 deleting
- 这样无需新增 CronJob 聚合，也无需改变你们的最终一致机制。

**删除/更新**
- DeleteCronJobCommandHandler：
  - 标记删除 Trigger 与 Source（可直接复用现有 DeleteTrigger/DeleteSource 的领域方法模式，但仍然不互调 handler；建议直接 load aggregate → call delete/markDeleting → save → outbox）
- UpdateCronJob：
  - 改 schedule：只更新 SourceSpec
  - 改 target sink：只更新 Trigger sink
  - 改 payload/ceOverrides：更新 SourceSpec（并注意 desiredSpecHash 收敛语义）

**幂等与重放（非常关键）**
- 你们领域约定幂等是 `BusinessKey(or AggregateId)+CommandType+IdempotencyKey`（见 eventing-domain. Md）。CronJob 这层最简单的幂等策略是：
  - CronJobName 在 tenant 内唯一
  - 子资源名字由 CronJobName 稳定派生
  - 同一个 `idempotencyKey` 重放会命中“已存在”检查，从而返回一致结果（或你可以改成 find-by-key then return existing id）
- 异步 apply 层本身也是可重放的（你们已经要求 event handler 幂等/可重入），因此组合创建不会破坏系统一致性。

如果你愿意，我可以再把“对外 API 的字段设计（CronJob 的 request/response）”也按你们现有 controller 风格给出一版，包括：
- CreateCronJob 返回 cronJobName + triggerId/sourceId
- GetCronJob 返回 combined status + 对应 trigger/source 详情链接/字段

# References