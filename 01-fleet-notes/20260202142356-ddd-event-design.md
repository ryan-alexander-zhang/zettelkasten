---
tags:
  - ddd
id: 20260202142404
created: 2026-02-02 14:24:04
status:
  - pending
  - done
  - in_progress
type: fleet-note
aliases:
  - ddd-event-design
---
## 1) 整个 Outbox 流程（按你现在这套代码）

  ### A. 业务事务内：把领域事件写进 Outbox（同一事务）

  1. 领域对象（通常是聚合根）在业务方法里调用 raise (event) 记录事件到内存列表
      - 领域层只负责“记录”，不负责“发布”（见 AggregateRoot #raise 的设计思想）。
  2. 应用层在保存聚合后，调用 DomainEventOutboxService.RecordPulledDomainEvents (...)：
      - Aggregate.PullDomainEvents () 把未提交事件一次性取出并清空。
      - 每个 DomainEvent 被转换成一条 OutboxMessage：
          - EventId/occurredAt 来自 DomainEvent
          - AggregateType/aggregateId/headers 来自 DomainEventContext
          - EventType 用 event.GetClass (). GetName ()
          - Payload 用 OutboxPayloadSerializer.Serialize (event) 得到字符串（start 里用 Jackson 默认序列化）
          - Attempts 初始化为 0
      - 最后调用 OutboxStore.Append (messages) 把消息批量落库到 outbox 表，状态为 NEW
        这一步必须处在“业务保存同一事务”里，才能保证“业务数据 + outbox”原子性。

  你现在的落库端口/实现链路是：

  - App：DomainEventOutboxService -> OutboxStore. Append
  - start：OutboxWiringConfig. MybatisOutboxStore #append -> infra：OutboxEventMapper. InsertBatch

  ### B. 异步 Relay：轮询 Outbox 并发布（至少一次 + 可重试）

  1. 定时触发：OutboxRelayJob（adapter. Scheduler）每隔 persimmon. Outbox. Relay. Fixed-delay-ms（默认 1000ms）执行一次。
  2. Job 调用 OutboxRelayService.RelayOnce (batchSize)：
      - OutboxStore.ClaimNextBatch (batchSize, now)：
          - 先 releaseExpiredLocks (now) 把超时的 SENDING 记录释放回 NEW（防止 worker 崩溃导致永远卡住）
          - LockNextBatchForSending (now, batchSize) 用 FOR UPDATE SKIP LOCKED 锁定一批可发送行（status=NEW 且 next_retry_at<=now）
          - 对锁到的每行执行 markSending (eventId, workerId, lockedUntil, now) 把状态改为 SENDING 并写入租约（locked_by/locked_until）
          - 映射成 OutboxMessage 列表返回给 relay
      - 对每条消息调用 OutboxTransport.Publish (message)：
          - 当前默认是 start 里的 LoggingOutboxTransport（只打日志，相当于 noop）
      - 成功：OutboxStore.MarkSent (eventId, sentAt) -> DB 标记 SENT/sent_at
      - 失败：计算重试间隔（RetryPolicy）并 markFailed (eventId, now, nextRetryAt, lastError)：
          - DB：status=FAILED、attempts=attempts+1、next_retry_at=...、记录 last_error
          - 下次 claim 时只有 status=NEW 会被抓取；所以失败记录当前不会再发（这里有个设计点：要不要把 FAILED 也视为可重试，会在下面“注意事项”提到）

  ———

  ## 2) 每个类的用途 + 字段含义

  ### App 层（persimmon-scaffold-app）

  #### DomainEventContext（record）

  文件：persimmon-scaffold/persimmon-scaffold-app/src/main/java/com/ryan/persimmon/app/common/outbox/model/DomainEventContext. Java:1

  - 用途：把“领域事件之外的上下文”带给 outbox（领域事件保持最小化）。
  - 字段：
      - AggregateType：聚合类型（谁发生变化），例如 "Order"、"DemoBiz"。
      - AggregateId：聚合 ID（哪个实例发生变化），这里用 UUID（你目前 infra/basePO 也用 UUID）。
      - Headers：透传元数据（如 traceId、tenantId、operatorId、版本号等），落库时序列化成 JSON 字符串。

  #### OutboxMessage（record）

  文件：.../OutboxMessage. Java:1

  - 用途：应用层对 outbox 行的通用表示（既用于 append，也用于 relay 读取后发送）。
  - 字段：
      - eventId：事件唯一标识（UUIDv7，和 domain DomainEvent #eventId () 一致），也是幂等关键。
      - OccurredAt：事件发生时间（domain occurredAt）。
      - AggregateType / aggregateId：同上，用于路由、排查、幂等聚合等。
      - EventType：事件语义类型（发生了什么），当前实现为事件 Java 类名（全限定名）。
      - Payload：事件负载（序列化后的字符串；建议最终用 JSON）。
      - Headers：元数据（Map），用于 trace/tenant/schemaVersion 等。
      - Attempts：发送尝试次数（来自 DB 的 attempts）。

  #### OutboxPayloadSerializer（接口）

  文件：.../port/OutboxPayloadSerializer. Java:1

  - 用途：把 DomainEvent 序列化成 outbox 的 payload 字符串；避免 app 直接依赖 infra 的序列化实现。
  - 方法：
      - Serialize (DomainEvent event)：返回 JSON 字符串（start 里用 Jackson 实现）。

  #### OutboxStore（接口）

  文件：.../port/OutboxStore. Java:1

  - 用途：outbox 的持久化端口（append/claim/更新状态）；实现放在 start（适配 infra mapper），不放 app。
  - 方法：
      - append (List<OutboxMessage>)：写入新消息为 NEW（要求在业务事务内）。
      - ClaimNextBatch (int, Instant)：领取要发送的一批消息（要求有并发安全：锁 + 状态更新）。
      - MarkSent (UUID, Instant)：标记成功。
      - MarkFailed (UUID, Instant, Instant, String)：标记失败并设置下次重试时间与错误信息。

  #### OutboxTransport（接口）

  文件：.../port/OutboxTransport. Java:1

  - 用途：把 OutboxMessage 发布到外部系统（MQ/HTTP/事件总线）。
  - 方法：
      - Publish (OutboxMessage)：可能抛异常；异常触发重试逻辑。

  #### RetryPolicy / ExponentialBackoffRetryPolicy

  文件：.../retry/*. Java

  - 用途：计算失败后的退避时间。
  - ExponentialBackoffRetryPolicy 字段：
      - BaseBackoff：初始退避（默认在 start 配 1 秒）
      - MaxBackoff：最大退避（默认 300 秒）
  - 计算：base * 2^(attempt-1)，上限 maxBackoff。

  #### DomainEventOutboxService

  文件：.../service/DomainEventOutboxService. Java:1

  - 用途：把聚合里“未提交领域事件”转换成 OutboxMessage 并 append（事务内）。
  - 字段：
      - OutboxStore：outbox 写入端口
      - PayloadSerializer：payload 序列化器
  - 核心行为：pullDomainEvents () -> OutboxMessage -> outboxStore. Append

  #### OutboxRelayService

  文件：.../service/OutboxRelayService. Java:1

  - 用途：轮询 outbox、发布、成功/失败状态更新（与定时触发解耦）。
  - 字段：
      - OutboxStore：领取与更新状态
      - OutboxTransport：实际发布
      - RetryPolicy：失败退避
      - Clock：取当前时间
  - 核心行为：claimNextBatch -> publish -> markSent/markFailed

  ———

  ### Infra 层（persimmon-scaffold-infra）

  #### V1.0.1__outbox_event. Sql（DDL）

  文件：persimmon-scaffold/persimmon-scaffold-infra/src/main/resources/db/migration/V1.0.1__outbox_event. Sql:1

  - 表：outbox_event
  - 字段（与你的代码一一对应）：
      - Event_id：主键，事件唯一 ID
      - Occurred_at：事件发生时间
      - Aggregate_type：聚合类型（谁）
      - Aggregate_id：聚合实例（哪个）
      - Event_type：事件类型（发生了什么）
      - Payload：序列化负载（当前用 text，后续可改 jsonb）
      - Headers：元数据（当前用 text 存 JSON）
      - Status：NEW/SENDING/SENT/FAILED（你当前 SQL/mapper 用这些字面量）
      - Attempts：发送次数（累计）
      - Next_retry_at：下次允许重试的时间点
      - Sent_at：成功发送时间
      - Locked_by / locked_until：领取租约（worker 标识 + 过期时间）
      - Last_error：最后一次失败原因
      - Created_at / updated_at：审计时间
  - 索引：
      - Idx_outbox_event_status_retry (status, next_retry_at, occurred_at)：加速 claim
      - Idx_outbox_event_lock (locked_until)：加速释放过期锁

  #### OutboxEventPO

  文件：.../infra/event/outbox/po/OutboxEventPO. Java:1

  - 用途：outbox_event 表的 PO（用于 mapper 入参/出参）。
  - 字段：就是上面 DDL 的 Java 映射（String headers/payload/status，时间用 Instant）。

  #### OutboxEventMapper

  文件：.../infra/event/outbox/mapper/OutboxEventMapper. Java:1

  - 用途：outbox_event 的核心 SQL 操作。
  - 关键方法：
      - InsertBatch：批量插入 NEW 事件
      - LockNextBatchForSending：FOR UPDATE SKIP LOCKED 锁定候选 NEW 行
      - MarkSending：把行改成 SENDING 并写入 locked_by/locked_until
      - MarkSent：标记 SENT
      - MarkFailed：标记 FAILED、attempts+1、写 next_retry_at/last_error
      - ReleaseExpiredLocks：把锁过期的 SENDING 释放回 NEW

  ———

  ### Start 层（persimmon-scaffold-start）

  #### MybatisMapperScanConfig（更新）

  文件：persimmon-scaffold/persimmon-scaffold-start/src/main/java/com/ryan/persimmon/start/config/scan/MybatisMapperScanConfig. Java:1

  - 用途：集中扫描 mapper。
  - 变更：新增扫描 com. Ryan. Persimmon. Infra. Event. Outbox，让 OutboxEventMapper 被注册。

  #### AdapterSchedulerScanConfig

  文件：.../start/config/scan/AdapterSchedulerScanConfig. Java:1

  - 用途：只扫描 adapter. Scheduler（避免把整个 adapter/web 等都扫进来），并启用 @EnableScheduling 让定时任务生效。

  #### OutboxWiringConfig

  文件：.../start/config/bean/OutboxWiringConfig. Java:1

  - 用途：把 app 层的 outbox 端口/服务装配成可运行的 Spring Bean，并把 infra mapper 适配为 OutboxStore。
  - 主要 Beans：
      - AppClock：Instant::now
      - RetryPolicy：指数退避（可通过配置覆盖 base/max）
      - OutboxPayloadSerializer：用 Jackson ObjectMapper 把 DomainEvent 序列化为 JSON 字符串
      - OutboxTransport：当前是 LoggingOutboxTransport（只打日志）
      - OutboxStore：MybatisOutboxStore（内部用 OutboxEventMapper 做 claim/append/mark）
      - DomainEventOutboxService / OutboxRelayService：app 的服务实例化

  MybatisOutboxStore 里有几个关键配置项（通过 @Value）：

  - Persimmon. Outbox. Relay. Worker-id：写入 locked_by（默认 local）
  - Persimmon. Outbox. Relay. Lease-seconds：租约时长（默认 30 秒）

  ———

  ### Adapter 层（persimmon-scaffold-adapter）

  #### OutboxRelayJob

  文件：persimmon-scaffold/persimmon-scaffold-adapter/src/main/java/com/ryan/persimmon/adapter/scheduler/biz/job/OutboxRelayJob. Java:1

  - 用途：定时触发 relay（入口层薄薄一层，只调用 app service）。
  - 字段：
      - OutboxRelayService：app 的 relay 服务（由 start 装配注入）
      - BatchSize：每次拉取批大小（persimmon. Outbox. Relay. Batch-size，默认 100）
  - 定时配置：
      - FixedDelayString = ${persimmon. Outbox. Relay. Fixed-delay-ms: 1000}

  ———

  ## 注意事项（你可能马上会问到的）

  - 现在 markFailed 把 status 设为 FAILED，但 claimNextBatch 只抓 status='NEW'；因此失败后不会自动重试。要实现“自动重试”，通常做法是：
      - 要么 markFailed 仍保持 NEW 并递增 attempts + next_retry_at
      - 要么 claimNextBatch 同时允许抓取 FAILED 且 next_retry_at<=now
        如果你确认期望行为，我可以把这块改成你想要的语义（并补一条 Arch/单测）。

  你希望失败后自动重试吗（是/否）？如果是，你更倾向上面哪一种状态模型？